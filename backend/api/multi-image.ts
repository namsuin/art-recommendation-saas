import { MultiImageAnalysisService, MULTI_IMAGE_PRICING } from '../services/multi-image-analysis';
import { ArtsyIntegration } from '../services/artsy-integration';
import { SocialMediaIntegration } from '../services/social-media-integration';
import { ExpandedArtSearchService } from '../services/expanded-art-search';
import { StripeService } from '../services/stripe';
import { supabase } from '../services/supabase';
import { mockDB } from '../services/mock-database';
import { ImageUrlValidator } from '../utils/image-url-validator';

export class MultiImageAPI {
  private multiImageService: MultiImageAnalysisService;
  private artsyIntegration: ArtsyIntegration;
  private socialMediaIntegration: SocialMediaIntegration;
  private expandedArtSearch: ExpandedArtSearchService;

  constructor() {
    this.multiImageService = new MultiImageAnalysisService();
    this.artsyIntegration = new ArtsyIntegration();
    this.socialMediaIntegration = new SocialMediaIntegration();
    this.expandedArtSearch = new ExpandedArtSearchService();
  }

  /**
   * Îã§Ï§ë Ïù¥ÎØ∏ÏßÄ Î∂ÑÏÑù ÏöîÏ≤≠ Ï≤òÎ¶¨
   */
  async analyzeMultipleImages(req: Request): Promise<Response> {
    try {
      console.log('üöÄ Starting multi-image analysis...');
      const formData = await req.formData();
      let rawUserId = formData.get('userId') as string | null;
      
      // Authorization Ìó§Îçî ÌôïÏù∏
      const authorization = req.headers.get('authorization');
      console.log('üîç Authorization header:', authorization ? 'present' : 'missing');
      
      // Bearer ÌÜ†ÌÅ∞ÏúºÎ°ú ÏÇ¨Ïö©Ïûê ÌôïÏù∏
      if (authorization && authorization.startsWith('Bearer ')) {
        try {
          const accessToken = authorization.slice(7);
          const { supabaseAdmin } = await import('../services/supabase');
          const { data: { user }, error } = await supabaseAdmin.auth.getUser(accessToken);
          
          if (!error && user) {
            rawUserId = user.id;
            console.log('‚úÖ User authenticated via token:', user.email);
          } else {
            console.log('‚ùå Token validation failed:', error);
          }
        } catch (tokenError) {
          console.log('‚ùå Token processing error:', tokenError);
        }
      }
      
      // Îπà Î¨∏ÏûêÏó¥Ïù¥ÎÇò nullÏùÑ Î™®Îëê nullÎ°ú Ï≤òÎ¶¨
      const userId = rawUserId && rawUserId.trim() !== '' ? rawUserId : null;
      
      // ÎîîÎ≤ÑÍπÖ: FormDataÏùò Î™®Îì† ÌÇ§Î•º ÌôïÏù∏
      const formDataKeys = Array.from(formData.keys());
      console.log('üìã FormData keys:', formDataKeys);
      console.log('üìã Raw User ID received:', rawUserId, typeof rawUserId);
      console.log('üìã Processed User ID:', userId, typeof userId);
      console.log('üìã User ID is null?', userId === null);

      // Ïù¥ÎØ∏ÏßÄ ÌååÏùºÎì§ Ï∂îÏ∂ú
      const imageFiles: File[] = [];
      const entries = Array.from(formData.entries());
      
      for (const [key, value] of entries) {
        if (key.startsWith('image') && value instanceof File) {
          imageFiles.push(value);
          console.log(`üì∑ Found image: ${key} - ${value.name} (${value.size} bytes)`);
        }
      }
      
      console.log(`üñºÔ∏è Total images found: ${imageFiles.length}`);

      if (imageFiles.length === 0) {
        return new Response(JSON.stringify({
          success: false,
          error: 'Î∂ÑÏÑùÌï† Ïù¥ÎØ∏ÏßÄÍ∞Ä ÏóÜÏäµÎãàÎã§.'
        }), {
          status: 400,
          headers: { 'Content-Type': 'application/json' }
        });
      }

      // Mock Î™®ÎìúÏùº Îïå Í∞ÑÎã®Ìïú Ï≤òÎ¶¨
      if (!supabase) {
        console.log('üé≠ Running in Mock mode - using mock recommendations');
        return this.handleMockMultiImageAnalysis(userId || 'anonymous', imageFiles);
      }

      // Í≤∞Ï†ú Ìã∞Ïñ¥ ÌôïÏù∏
      const tier = MultiImageAnalysisService.calculatePaymentTier(imageFiles.length);
      const permission = await this.multiImageService.checkAnalysisPermission(userId, imageFiles.length);

      if (!permission.canAnalyze && permission.paymentRequired) {
        return new Response(JSON.stringify({
          success: false,
          error: 'Í≤∞Ï†úÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§.',
          paymentRequired: true,
          tier: tier,
          paymentUrl: await this.createPaymentSession(userId, tier)
        }), {
          status: 402, // Payment Required
          headers: { 'Content-Type': 'application/json' }
        });
      }

      // Ïù¥ÎØ∏ÏßÄÎ•º Î≤ÑÌçºÎ°ú Î≥ÄÌôò
      console.log('üîÑ Converting images to buffers...');
      const imageBuffers = await Promise.all(
        imageFiles.map(async (file) => Buffer.from(await file.arrayBuffer()))
      );
      console.log('‚úÖ Buffer conversion complete');

      // Îã§Ï§ë Ïù¥ÎØ∏ÏßÄ Î∂ÑÏÑù Ïã§Ìñâ
      console.log('üéØ Starting AI analysis...');
      const analysisResult = await this.multiImageService.analyzeMultipleImages(imageBuffers, {
        userId,
        analysisType: 'batch',
        findCommonKeywords: true
      });

      console.log('üìä Analysis result:', analysisResult.success ? 'SUCCESS' : 'FAILED');
      
      if (!analysisResult.success) {
        console.error('‚ùå Analysis failed:', analysisResult.error);
        return new Response(JSON.stringify(analysisResult), {
          status: 500,
          headers: { 'Content-Type': 'application/json' }
        });
      }

      // Mock Îç∞Ïù¥ÌÑ∞Î•º Ï∂îÍ∞ÄÌïòÏó¨ ÏµúÏÜåÌïúÏùò Ï∂îÏ≤ú ÏûëÌíà Î≥¥Ïû•
      console.log('üéØ Adding mock recommendations as fallback');
      const mockRecommendations = await mockDB.getRecommendations(
        analysisResult.commonKeywords?.keywords || ['artwork', 'creative', 'visual']
      );
      console.log('üìä Mock recommendations retrieved:', mockRecommendations.length);
      
      // Mock Ï∂îÏ≤úÏùÑ internal Î∞∞Ïó¥Ïóê Ï∂îÍ∞Ä
      if (!analysisResult.recommendations) {
        analysisResult.recommendations = [];
      }
      analysisResult.recommendations.push(...mockRecommendations);

      // Ïô∏Î∂Ä ÌîåÎû´ÌèºÏóêÏÑú Ï∂îÍ∞Ä Ï∂îÏ≤ú Í≤ÄÏÉâ (ÌôïÏû•Îêú ÏÜåÏä§ Ìè¨Ìï®)
      let externalRecommendations: any[] = [];
      if (analysisResult.commonKeywords && analysisResult.commonKeywords.keywords.length > 0) {
        const topKeywords = analysisResult.commonKeywords.keywords.slice(0, 5);
        
        console.log('üåç Searching expanded art sources...');
        
        try {
          // ÌôïÏû•Îêú ÎØ∏Ïà†Í¥Ä Í≤ÄÏÉâ (Chicago, Rijksmuseum, Íµ≠Î¶ΩÏ§ëÏïôÎ∞ïÎ¨ºÍ¥Ä Ìè¨Ìï®)
          const expandedSearchResults = await this.expandedArtSearch.searchAllSources(
            topKeywords,
            {
              sources: ['chicago', 'rijksmuseum', 'korea'],
              limit: 5,
              includeKorean: true
            }
          );

          if (expandedSearchResults.success) {
            expandedSearchResults.results.forEach(sourceResult => {
              console.log(`üìç ${sourceResult.source}: Found ${sourceResult.artworks.length} artworks`);
              externalRecommendations.push(...sourceResult.artworks);
            });
          }

          // Í∏∞Ï°¥ Artsy Í≤ÄÏÉâÎèÑ Ïú†ÏßÄ
          const artsyResults = await this.artsyIntegration.searchByKeywords(topKeywords, 5);
          externalRecommendations.push(...artsyResults.artworks.map(artwork => 
            this.artsyIntegration.formatForDisplay(artwork)
          ));

          // ÏÜåÏÖú ÎØ∏ÎîîÏñ¥ Í≤ÄÏÉâ
          const socialResults = await this.socialMediaIntegration.searchAllPlatforms(
            topKeywords,
            ['behance'],
            5
          );
          externalRecommendations.push(...socialResults.results);
        } catch (error) {
          console.error('üö´ External search failed, using mock data only:', error);
        }
      }

      // Ïô∏Î∂Ä Ï∂îÏ≤úÏóêÎèÑ Ïú†ÏÇ¨ÎèÑ Ï∂îÍ∞Ä
      if (analysisResult.commonKeywords && externalRecommendations.length > 0) {
        const multiImageService = this.multiImageService;
        externalRecommendations = externalRecommendations.map(artwork => {
          const similarity = multiImageService.calculateSimilarityScore(
            analysisResult.commonKeywords!.keywords,
            artwork.keywords || artwork.tags || [],
            analysisResult.commonKeywords!.confidence
          );
          
          return {
            ...artwork,
            similarity_score: similarity.total,
            similarity_details: similarity
          };
        });
        
        // Ïú†ÏÇ¨ÎèÑ ÏàúÏúºÎ°ú Ï†ïÎ†¨
        externalRecommendations.sort((a, b) => b.similarity_score - a.similarity_score);
      }

      // Ïù¥ÎØ∏ÏßÄ URL Ïú†Ìö®ÏÑ± Í≤ÄÏ¶ù Î∞è ÌïÑÌÑ∞ÎßÅ
      console.log('üîç Validating recommendation image URLs...');
      const validatedInternalRecommendations = await ImageUrlValidator.filterValidRecommendations(
        analysisResult.recommendations || []
      );
      const validatedExternalRecommendations = await ImageUrlValidator.filterValidRecommendations(
        externalRecommendations
      );

      console.log(`üìä Image validation complete - Internal: ${validatedInternalRecommendations.length}/${(analysisResult.recommendations || []).length}, External: ${validatedExternalRecommendations.length}/${externalRecommendations.length}`);

      return new Response(JSON.stringify({
        success: true,
        imageCount: imageFiles.length,
        tier: tier.name,
        results: analysisResult.results,
        commonKeywords: {
          ...analysisResult.commonKeywords,
          totalSimilarityScore: analysisResult.commonKeywords ? 
            Math.round(analysisResult.commonKeywords.confidence * 100) : 0
        },
        recommendations: {
          internal: validatedInternalRecommendations,
          external: validatedExternalRecommendations
        },
        processingTime: analysisResult.processingTime,
        similarityAnalysis: {
          averageSimilarity: validatedInternalRecommendations.length > 0 ? 
            Math.round((validatedInternalRecommendations.reduce((sum: number, rec: any) => 
              sum + (rec.similarity_score?.total || rec.similarity || 0), 0) / validatedInternalRecommendations.length) * 100) : 0,
          topMatches: validatedInternalRecommendations.slice(0, 3).map((rec: any) => ({
            title: (rec.artwork || rec).title || 'Ï†úÎ™© ÏóÜÏùå',
            similarity: Math.round(((rec.similarity_score?.total || rec.similarity || 0)) * 100),
            matchedKeywords: rec.similarity_score?.matchedKeywords || rec.matchingKeywords || []
          }))
        }
      }), {
        headers: { 'Content-Type': 'application/json' }
      });

    } catch (error) {
      console.error('Multi-image analysis error:', error);
      return new Response(JSON.stringify({
        success: false,
        error: error instanceof Error ? error.message : 'Î∂ÑÏÑù Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.'
      }), {
        status: 500,
        headers: { 'Content-Type': 'application/json' }
      });
    }
  }

  /**
   * Îã§Ï§ë Ïù¥ÎØ∏ÏßÄ Î∂ÑÏÑùÏùÑ ÏúÑÌïú Í≤∞Ï†ú ÏÑ∏ÏÖò ÏÉùÏÑ±
   */
  private async createPaymentSession(userId: string, tier: any): Promise<string | null> {
    if (!StripeService.isConfigured() || tier.price === 0) {
      return null;
    }

    try {
      const stripe = new (await import('stripe')).default(process.env.STRIPE_SECRET_KEY!, {
        apiVersion: '2023-10-16'
      });

      // ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ Ï°∞Ìöå
      const { data: user } = await supabase!
        .from('users')
        .select('email, display_name')
        .eq('id', userId)
        .single();

      if (!user) {
        return null;
      }

      // Stripe Í≥†Í∞ù ÏÉùÏÑ±/Ï°∞Ìöå
      const customer = await StripeService.getOrCreateCustomer(userId, user.email, user.display_name);
      if (!customer) {
        return null;
      }

      // ÏùºÌöåÏÑ± Í≤∞Ï†ú ÏÑ∏ÏÖò ÏÉùÏÑ±
      const session = await stripe.checkout.sessions.create({
        customer: customer.id,
        payment_method_types: ['card'],
        line_items: [{
          price_data: {
            currency: 'usd',
            product_data: {
              name: tier.name,
              description: tier.description,
            },
            unit_amount: tier.price, // cents
          },
          quantity: 1,
        }],
        mode: 'payment',
        success_url: `${process.env.FRONTEND_URL}/analysis/success?session_id={CHECKOUT_SESSION_ID}`,
        cancel_url: `${process.env.FRONTEND_URL}/analysis/cancel`,
        metadata: {
          userId,
          analysisType: 'multi_image',
          tier: tier.name,
          maxImages: tier.maxImages.toString()
        }
      });

      return session.url;

    } catch (error) {
      console.error('Failed to create payment session:', error);
      return null;
    }
  }

  /**
   * Í≤∞Ï†ú ÏÑ±Í≥µ ÌõÑ Ï≤òÎ¶¨
   */
  async handlePaymentSuccess(sessionId: string): Promise<{
    success: boolean;
    error?: string;
  }> {
    if (!StripeService.isConfigured()) {
      return { success: false, error: 'Stripe not configured' };
    }

    try {
      const stripe = new (await import('stripe')).default(process.env.STRIPE_SECRET_KEY!, {
        apiVersion: '2023-10-16'
      });

      // ÏÑ∏ÏÖò Ï†ïÎ≥¥ Ï°∞Ìöå
      const session = await stripe.checkout.sessions.retrieve(sessionId);
      
      if (session.payment_status !== 'paid') {
        return { success: false, error: 'Í≤∞Ï†úÍ∞Ä ÏôÑÎ£åÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.' };
      }

      const { userId, tier, maxImages } = session.metadata!;

      // Í≤∞Ï†ú Í∏∞Î°ù Ï†ÄÏû•
      if (supabase) {
        const { error } = await supabase
          .from('multi_image_payments')
          .insert({
            user_id: userId,
            stripe_session_id: sessionId,
            tier: tier,
            max_images: parseInt(maxImages),
            amount: session.amount_total! / 100, // Convert from cents
            currency: session.currency,
            status: 'completed',
            expires_at: new Date(Date.now() + 24 * 60 * 60 * 1000) // 24ÏãúÍ∞Ñ Ïú†Ìö®
          });

        if (error) {
          console.error('Failed to save payment record:', error);
        }
      }

      return { success: true };

    } catch (error) {
      console.error('Payment success handling error:', error);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Í≤∞Ï†ú Ï≤òÎ¶¨ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.' 
      };
    }
  }

  /**
   * ÏÇ¨Ïö©ÏûêÏùò Îã§Ï§ë Ïù¥ÎØ∏ÏßÄ Î∂ÑÏÑù ÌûàÏä§ÌÜ†Î¶¨ Ï°∞Ìöå
   */
  async getUserAnalysisHistory(userId: string, limit: number = 20): Promise<Response> {
    try {
      const result = await this.multiImageService.getUserAnalysisHistory(userId, limit);
      
      return new Response(JSON.stringify(result), {
        status: result.success ? 200 : 500,
        headers: { 'Content-Type': 'application/json' }
      });

    } catch (error) {
      return new Response(JSON.stringify({
        success: false,
        error: 'ÌûàÏä§ÌÜ†Î¶¨ Ï°∞Ìöå Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.'
      }), {
        status: 500,
        headers: { 'Content-Type': 'application/json' }
      });
    }
  }

  /**
   * Ïô∏Î∂Ä ÌîåÎû´Ìèº Í≤ÄÏÉâ API
   */
  async searchExternalPlatforms(req: Request): Promise<Response> {
    try {
      const { keywords, platforms = ['artsy', 'behance'], limit = 20 } = await req.json();

      if (!keywords || !Array.isArray(keywords) || keywords.length === 0) {
        return new Response(JSON.stringify({
          success: false,
          error: 'Í≤ÄÏÉâ ÌÇ§ÏõåÎìúÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§.'
        }), {
          status: 400,
          headers: { 'Content-Type': 'application/json' }
        });
      }

      const results: any = {
        artsy: [],
        social: []
      };

      // Artsy Í≤ÄÏÉâ
      if (platforms.includes('artsy')) {
        const artsyResults = await this.artsyIntegration.searchByKeywords(keywords, limit);
        results.artsy = artsyResults.artworks.map(artwork => 
          this.artsyIntegration.formatForDisplay(artwork)
        );
      }

      // ÏÜåÏÖú ÎØ∏ÎîîÏñ¥ Í≤ÄÏÉâ
      const socialPlatforms = platforms.filter(p => ['instagram', 'behance', 'pinterest'].includes(p));
      if (socialPlatforms.length > 0) {
        const socialResults = await this.socialMediaIntegration.searchAllPlatforms(
          keywords,
          socialPlatforms as any,
          Math.floor(limit / socialPlatforms.length)
        );
        results.social = socialResults.results;
      }

      return new Response(JSON.stringify({
        success: true,
        keywords,
        results,
        total: results.artsy.length + results.social.length
      }), {
        headers: { 'Content-Type': 'application/json' }
      });

    } catch (error) {
      console.error('External platform search error:', error);
      return new Response(JSON.stringify({
        success: false,
        error: 'Ïô∏Î∂Ä ÌîåÎû´Ìèº Í≤ÄÏÉâ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.'
      }), {
        status: 500,
        headers: { 'Content-Type': 'application/json' }
      });
    }
  }

  /**
   * Mock Îã§Ï§ë Ïù¥ÎØ∏ÏßÄ Î∂ÑÏÑù Ï≤òÎ¶¨
   */
  private async handleMockMultiImageAnalysis(userId: string, imageFiles: File[]): Promise<Response> {
    try {
      console.log(`üé≠ Mock analysis for ${imageFiles.length} images`);
      
      // Í∏∞Î≥∏ ÌÇ§ÏõåÎìú ÏÉùÏÑ± (Ïù¥ÎØ∏ÏßÄ Í∞úÏàòÏóê Îî∞Îùº)
      const commonKeywords = ['artwork', 'visual-art', 'creative', 'painting', 'aesthetic'];
      if (imageFiles.length > 2) {
        commonKeywords.push('collection', 'series', 'exhibition');
      }

      // Mock Ï∂îÏ≤ú Í≤∞Í≥º ÏÉùÏÑ±
      console.log('üéØ Getting mock recommendations with keywords:', commonKeywords);
      const mockRecommendations = await mockDB.getRecommendations(commonKeywords);
      console.log('üìä Mock recommendations found:', mockRecommendations.length);

      // Í≤∞Ï†ú Ìã∞Ïñ¥ Í≥ÑÏÇ∞
      const tier = MultiImageAnalysisService.calculatePaymentTier(imageFiles.length);
      
      // Mock Ï∂îÏ≤úÏóê ÎåÄÌï¥ÏÑúÎèÑ Ïù¥ÎØ∏ÏßÄ URL Ïú†Ìö®ÏÑ± Í≤ÄÏ¶ù
      console.log('üîç Validating mock recommendation image URLs...');
      const validatedMockRecommendations = await ImageUrlValidator.filterValidRecommendations(mockRecommendations);
      console.log(`üìä Mock image validation complete: ${validatedMockRecommendations.length}/${mockRecommendations.length}`);
      
      // Ï†ïÏÉÅÏ†ÅÏù∏ API ÏùëÎãµ ÌòïÏãùÏóê ÎßûÏ∂§
      return new Response(JSON.stringify({
        success: true,
        imageCount: imageFiles.length,
        tier: tier.name,
        results: imageFiles.map((_, index) => ({
          keywords: ['artwork', 'visual-art', 'creative'],
          colors: ['blue', 'red'],
          style: 'mixed',
          mood: 'balanced',
          confidence: 0.85,
          embeddings: [],
          ai_sources: {
            clarifai: { concepts: [], colors: [] }
          }
        })),
        commonKeywords: {
          keywords: commonKeywords,
          confidence: 0.85,
          frequency: commonKeywords.reduce((freq, keyword) => ({ ...freq, [keyword]: 1 }), {}),
          totalSimilarityScore: Math.round(Math.random() * 30 + 70) // 70-100%
        },
        recommendations: {
          internal: validatedMockRecommendations,
          external: []
        },
        processingTime: Math.random() * 2000 + 1000, // 1-3Ï¥à
        similarityAnalysis: {
          averageSimilarity: Math.round(Math.random() * 30 + 70),
          topMatches: validatedMockRecommendations.slice(0, 3).map(rec => ({
            title: rec.artwork.title,
            similarity: Math.round((rec.similarity || 0.8) * 100),
            matchedKeywords: rec.matchingKeywords || commonKeywords.slice(0, 3)
          }))
        }
      }), {
        headers: { 'Content-Type': 'application/json' }
      });

    } catch (error) {
      console.error('Mock multi-image analysis error:', error);
      return new Response(JSON.stringify({
        success: false,
        error: 'Îã§Ï§ë Ïù¥ÎØ∏ÏßÄ Î∂ÑÏÑù Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.'
      }), {
        status: 500,
        headers: { 'Content-Type': 'application/json' }
      });
    }
  }
}

// Ïã±Í∏ÄÌÜ§ Ïù∏Ïä§ÌÑ¥Ïä§
let multiImageAPIInstance: MultiImageAPI | null = null;

export function getMultiImageAPI(): MultiImageAPI {
  if (!multiImageAPIInstance) {
    multiImageAPIInstance = new MultiImageAPI();
  }
  return multiImageAPIInstance;
}